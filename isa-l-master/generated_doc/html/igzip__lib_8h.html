<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Intel Intelligent Storage Acceleration Library: igzip_lib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Intel Intelligent Storage Acceleration Library
   &#160;<span id="projectnumber">2.30.0</span>
   </div>
   <div id="projectbrief">ISA-L API reference doc</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('igzip__lib_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">igzip_lib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines the igzip compression and decompression interface, a high performance deflate compression interface for storage applications.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
</div>
<p><a href="igzip__lib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds histogram of deflate symbols.  <a href="structisal__huff__histogram.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__mod__hist.html">isal_mod_hist</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBitBuf2.html">BitBuf2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds Bit Buffer information.  <a href="structBitBuf2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__zlib__header.html">isal_zlib_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__gzip__header.html">isal_gzip_header</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__zstate.html">isal_zstate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the internal state information for input and output compression streams.  <a href="structisal__zstate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__hufftables.html">isal_hufftables</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the huffman tree used to huffman encode the input stream.  <a href="structisal__hufftables.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__zstream.html">isal_zstream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds stream information.  <a href="structisal__zstream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinflate__huff__code__large.html">inflate_huff_code_large</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinflate__huff__code__small.html">inflate_huff_code_small</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinflate__state.html">inflate_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds decompression state information.  <a href="structinflate__state.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structisal__dict.html">isal_dict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for holding processed dictionary information.  <a href="structisal__dict.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a15a192d6ccce5232a81e04a89e546025"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025">isal_zstate_state</a> { <br/>
&#160;&#160;<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025ae29ac79025884cb44734bf6cc1c2dc8a">ZSTATE_NEW_HDR</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a0732985b5f3f6326df79d3a9602a5d28">ZSTATE_HDR</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025aa1f5cabded72c30de4d7d259045be9d6">ZSTATE_CREATE_HDR</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a19eb4a317476d06fe3aeb5747b4bdd94">ZSTATE_BODY</a>, 
<br/>
&#160;&#160;<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a109b2268f524b66c72e518926d6a50e1">ZSTATE_FLUSH_READ_BUFFER</a>
, <a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a5176ea8c48e72828d68a623e1c6adf8b">ZSTATE_TYPE0_BODY</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025ad1bc4b252110bf3a966b60bdf1e47933">ZSTATE_SYNC_FLUSH</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a06bfbb1c73e37a846f8d49444c77ef09">ZSTATE_FLUSH_WRITE_BUFFER</a>, 
<br/>
&#160;&#160;<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a88bfe2520b8b8075ac982cf78f299629">ZSTATE_TRL</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025aed309f0832206a73cc9d3ca7ca1cefcc">ZSTATE_END</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025ac51b1849e58365ad73de62a6dd48d8af">ZSTATE_TMP_NEW_HDR</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a9022a6088ebb9bd63824c30fdc9bb7e6">ZSTATE_TMP_HDR</a>, 
<br/>
&#160;&#160;<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a4987d9d303e6fb02ec68b7279e561a5f">ZSTATE_TMP_CREATE_HDR</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025ad6f44c8d6ac1935f2ab547492dbfafc0">ZSTATE_TMP_BODY</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025aef8435f222e77fa05a876babf8096922">ZSTATE_TMP_FLUSH_READ_BUFFER</a>
, <a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a42d4ad449237e3adb254121514ffe552">ZSTATE_TMP_TYPE0_BODY</a>, 
<br/>
&#160;&#160;<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025aeeab8dee9837e67fb0439e8c1b7bc8e2">ZSTATE_TMP_SYNC_FLUSH</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025a206cc526da1927e20bbff7f1518c641c">ZSTATE_TMP_FLUSH_WRITE_BUFFER</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025aa6a864ea51b7f866425ca5e5dc155194">ZSTATE_TMP_TRL</a>, 
<a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025ad7db4e6c908ed5949574b81a19f829f9">ZSTATE_TMP_END</a>
<br/>
 }</td></tr>
<tr class="memdesc:a15a192d6ccce5232a81e04a89e546025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compression State please note ZSTATE_TRL only applies for GZIP compression.  <a href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025">More...</a><br/></td></tr>
<tr class="separator:a15a192d6ccce5232a81e04a89e546025"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abcf32e76e2b6802792a5ceb4b51f1c4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#abcf32e76e2b6802792a5ceb4b51f1c4e">isal_update_histogram</a> (uint8_t *in_stream, int length, struct <a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a> *histogram)</td></tr>
<tr class="memdesc:abcf32e76e2b6802792a5ceb4b51f1c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates histograms to include the symbols found in the input stream. Since this function only updates the histograms, it can be called on multiple streams to get a histogram better representing the desired data set. When first using histogram it must be initialized by zeroing the structure.  <a href="#abcf32e76e2b6802792a5ceb4b51f1c4e">More...</a><br/></td></tr>
<tr class="separator:abcf32e76e2b6802792a5ceb4b51f1c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4699267b60c1b57c034b2adc612ee7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a4d4699267b60c1b57c034b2adc612ee7">isal_create_hufftables</a> (struct <a class="el" href="structisal__hufftables.html">isal_hufftables</a> *hufftables, struct <a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a> *histogram)</td></tr>
<tr class="memdesc:a4d4699267b60c1b57c034b2adc612ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom huffman code for the given histograms in which every literal and repeat length is assigned a code and all possible lookback distances are assigned a code.  <a href="#a4d4699267b60c1b57c034b2adc612ee7">More...</a><br/></td></tr>
<tr class="separator:a4d4699267b60c1b57c034b2adc612ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45350d816cfdcbad55ec95284776af3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#aa45350d816cfdcbad55ec95284776af3">isal_create_hufftables_subset</a> (struct <a class="el" href="structisal__hufftables.html">isal_hufftables</a> *hufftables, struct <a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a> *histogram)</td></tr>
<tr class="memdesc:aa45350d816cfdcbad55ec95284776af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a custom huffman code for the given histograms like <a class="el" href="igzip__lib_8h.html#a4d4699267b60c1b57c034b2adc612ee7" title="Creates a custom huffman code for the given histograms in which every literal and repeat length is as...">isal_create_hufftables()</a> except literals with 0 frequency in the histogram are not assigned a code.  <a href="#aa45350d816cfdcbad55ec95284776af3">More...</a><br/></td></tr>
<tr class="separator:aa45350d816cfdcbad55ec95284776af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d311328df613652c3d1606d4a0297c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a6d311328df613652c3d1606d4a0297c7">isal_deflate_init</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream)</td></tr>
<tr class="memdesc:a6d311328df613652c3d1606d4a0297c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize compression stream data structure.  <a href="#a6d311328df613652c3d1606d4a0297c7">More...</a><br/></td></tr>
<tr class="separator:a6d311328df613652c3d1606d4a0297c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae582f5e4fc6a35ab8796949660259178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#ae582f5e4fc6a35ab8796949660259178">isal_deflate_reset</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream)</td></tr>
<tr class="memdesc:ae582f5e4fc6a35ab8796949660259178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize compression stream data structure. Performs the same action as isal_deflate_init, but does not change user supplied input such as the level, flush type, compression wrapper (like gzip), hufftables, and end_of_stream_flag.  <a href="#ae582f5e4fc6a35ab8796949660259178">More...</a><br/></td></tr>
<tr class="separator:ae582f5e4fc6a35ab8796949660259178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa595cf3fdcb8f40f5ded192944c54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#aafa595cf3fdcb8f40f5ded192944c54b">isal_gzip_header_init</a> (struct <a class="el" href="structisal__gzip__header.html">isal_gzip_header</a> *gz_hdr)</td></tr>
<tr class="memdesc:aafa595cf3fdcb8f40f5ded192944c54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set gzip header default values.  <a href="#aafa595cf3fdcb8f40f5ded192944c54b">More...</a><br/></td></tr>
<tr class="separator:aafa595cf3fdcb8f40f5ded192944c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5fe18579896416b7477e6598489b28"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a2e5fe18579896416b7477e6598489b28">isal_write_gzip_header</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream, struct <a class="el" href="structisal__gzip__header.html">isal_gzip_header</a> *gz_hdr)</td></tr>
<tr class="memdesc:a2e5fe18579896416b7477e6598489b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write gzip header to output stream.  <a href="#a2e5fe18579896416b7477e6598489b28">More...</a><br/></td></tr>
<tr class="separator:a2e5fe18579896416b7477e6598489b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6409a35e068fc012e37f85fa189a999"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#ac6409a35e068fc012e37f85fa189a999">isal_write_zlib_header</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream, struct <a class="el" href="structisal__zlib__header.html">isal_zlib_header</a> *z_hdr)</td></tr>
<tr class="memdesc:ac6409a35e068fc012e37f85fa189a999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write zlib header to output stream.  <a href="#ac6409a35e068fc012e37f85fa189a999">More...</a><br/></td></tr>
<tr class="separator:ac6409a35e068fc012e37f85fa189a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142e998c9897b815135742ff04102978"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a142e998c9897b815135742ff04102978">isal_deflate_set_hufftables</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream, struct <a class="el" href="structisal__hufftables.html">isal_hufftables</a> *hufftables, int type)</td></tr>
<tr class="memdesc:a142e998c9897b815135742ff04102978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stream to use a new Huffman code.  <a href="#a142e998c9897b815135742ff04102978">More...</a><br/></td></tr>
<tr class="separator:a142e998c9897b815135742ff04102978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae02071c5f41de12b7350dc90b314fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#aeae02071c5f41de12b7350dc90b314fc">isal_deflate_stateless_init</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream)</td></tr>
<tr class="memdesc:aeae02071c5f41de12b7350dc90b314fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize compression stream data structure.  <a href="#aeae02071c5f41de12b7350dc90b314fc">More...</a><br/></td></tr>
<tr class="separator:aeae02071c5f41de12b7350dc90b314fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ee0a2ceecb012c2f5db98541d6bd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a645ee0a2ceecb012c2f5db98541d6bd7">isal_deflate_set_dict</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream, uint8_t *dict, uint32_t dict_len)</td></tr>
<tr class="memdesc:a645ee0a2ceecb012c2f5db98541d6bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set compression dictionary to use.  <a href="#a645ee0a2ceecb012c2f5db98541d6bd7">More...</a><br/></td></tr>
<tr class="separator:a645ee0a2ceecb012c2f5db98541d6bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15edadeb459a40840e6c2f4baa59fb12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a15edadeb459a40840e6c2f4baa59fb12">isal_deflate_process_dict</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream, struct <a class="el" href="structisal__dict.html">isal_dict</a> *dict_str, uint8_t *dict, uint32_t dict_len)</td></tr>
<tr class="memdesc:a15edadeb459a40840e6c2f4baa59fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process dictionary to reuse later.  <a href="#a15edadeb459a40840e6c2f4baa59fb12">More...</a><br/></td></tr>
<tr class="separator:a15edadeb459a40840e6c2f4baa59fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36116973797161ef4243c49c68b64cc2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a36116973797161ef4243c49c68b64cc2">isal_deflate_reset_dict</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream, struct <a class="el" href="structisal__dict.html">isal_dict</a> *dict_str)</td></tr>
<tr class="memdesc:a36116973797161ef4243c49c68b64cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset compression dictionary to use.  <a href="#a36116973797161ef4243c49c68b64cc2">More...</a><br/></td></tr>
<tr class="separator:a36116973797161ef4243c49c68b64cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d8cde91439b0aeb10b357075560e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0">isal_deflate</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream)</td></tr>
<tr class="memdesc:a3a6d8cde91439b0aeb10b357075560e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast data (deflate) compression for storage applications.  <a href="#a3a6d8cde91439b0aeb10b357075560e0">More...</a><br/></td></tr>
<tr class="separator:a3a6d8cde91439b0aeb10b357075560e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd4d4c13d44fe96ca0d37d169fbf525"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a2dd4d4c13d44fe96ca0d37d169fbf525">isal_deflate_stateless</a> (struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *stream)</td></tr>
<tr class="memdesc:a2dd4d4c13d44fe96ca0d37d169fbf525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast data (deflate) stateless compression for storage applications.  <a href="#a2dd4d4c13d44fe96ca0d37d169fbf525">More...</a><br/></td></tr>
<tr class="separator:a2dd4d4c13d44fe96ca0d37d169fbf525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00513fdbbc6688c613d1a41b694ad168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a00513fdbbc6688c613d1a41b694ad168">isal_inflate_init</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state)</td></tr>
<tr class="memdesc:a00513fdbbc6688c613d1a41b694ad168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize decompression state data structure.  <a href="#a00513fdbbc6688c613d1a41b694ad168">More...</a><br/></td></tr>
<tr class="separator:a00513fdbbc6688c613d1a41b694ad168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d86fe1b62a34074e908390b17e5a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#af6d86fe1b62a34074e908390b17e5a31">isal_inflate_reset</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state)</td></tr>
<tr class="memdesc:af6d86fe1b62a34074e908390b17e5a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize decompression state data structure.  <a href="#af6d86fe1b62a34074e908390b17e5a31">More...</a><br/></td></tr>
<tr class="separator:af6d86fe1b62a34074e908390b17e5a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5a24dc5d4f9a9ca3bf08b5bb0274ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a5a5a24dc5d4f9a9ca3bf08b5bb0274ff">isal_inflate_set_dict</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state, uint8_t *dict, uint32_t dict_len)</td></tr>
<tr class="memdesc:a5a5a24dc5d4f9a9ca3bf08b5bb0274ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set decompression dictionary to use.  <a href="#a5a5a24dc5d4f9a9ca3bf08b5bb0274ff">More...</a><br/></td></tr>
<tr class="separator:a5a5a24dc5d4f9a9ca3bf08b5bb0274ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd333cf5024c376599a3fd8fb616b7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a7fd333cf5024c376599a3fd8fb616b7d">isal_read_gzip_header</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state, struct <a class="el" href="structisal__gzip__header.html">isal_gzip_header</a> *gz_hdr)</td></tr>
<tr class="memdesc:a7fd333cf5024c376599a3fd8fb616b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return gzip header information.  <a href="#a7fd333cf5024c376599a3fd8fb616b7d">More...</a><br/></td></tr>
<tr class="separator:a7fd333cf5024c376599a3fd8fb616b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af9bf84dd7ca9a60eb1d07bad4a7c76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#a4af9bf84dd7ca9a60eb1d07bad4a7c76">isal_read_zlib_header</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state, struct <a class="el" href="structisal__zlib__header.html">isal_zlib_header</a> *zlib_hdr)</td></tr>
<tr class="memdesc:a4af9bf84dd7ca9a60eb1d07bad4a7c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read and return zlib header information.  <a href="#a4af9bf84dd7ca9a60eb1d07bad4a7c76">More...</a><br/></td></tr>
<tr class="separator:a4af9bf84dd7ca9a60eb1d07bad4a7c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8842e2100d3b52b94943afa5a0c5979"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#ad8842e2100d3b52b94943afa5a0c5979">isal_inflate</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state)</td></tr>
<tr class="memdesc:ad8842e2100d3b52b94943afa5a0c5979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast data (deflate) decompression for storage applications.  <a href="#ad8842e2100d3b52b94943afa5a0c5979">More...</a><br/></td></tr>
<tr class="separator:ad8842e2100d3b52b94943afa5a0c5979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb59d093d9b8b621285fef81f82e4c0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#adb59d093d9b8b621285fef81f82e4c0c">isal_inflate_stateless</a> (struct <a class="el" href="structinflate__state.html">inflate_state</a> *state)</td></tr>
<tr class="memdesc:adb59d093d9b8b621285fef81f82e4c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast data (deflate) stateless decompression for storage applications.  <a href="#adb59d093d9b8b621285fef81f82e4c0c">More...</a><br/></td></tr>
<tr class="separator:adb59d093d9b8b621285fef81f82e4c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2adc31ec28075401ffae270df525593"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="igzip__lib_8h.html#ac2adc31ec28075401ffae270df525593">isal_adler32</a> (uint32_t init, const unsigned char *buf, uint64_t len)</td></tr>
<tr class="memdesc:ac2adc31ec28075401ffae270df525593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Adler-32 checksum, runs appropriate version.  <a href="#ac2adc31ec28075401ffae270df525593">More...</a><br/></td></tr>
<tr class="separator:ac2adc31ec28075401ffae270df525593"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines the igzip compression and decompression interface, a high performance deflate compression interface for storage applications. </p>
<p>Deflate is a widely used compression standard that can be used standalone, it also forms the basis of gzip and zlib compression formats. Igzip supports the following flush features:</p>
<ul>
<li>No Flush: The default method where no special flush is performed.</li>
<li>Sync flush: whereby <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a> finishes the current deflate block at the end of each input buffer. The deflate block is byte aligned by appending an empty stored block.</li>
<li>Full flush: whereby <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a> finishes and aligns the deflate block as in sync flush but also ensures that subsequent block's history does not look back beyond this point and new blocks are fully independent.</li>
</ul>
<p>Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to ISAL_DEF_MAX_LEVEL.</p>
<p>Igzip contains some behavior configurable at compile time. These configurable options are:</p>
<ul>
<li>IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K represents 1024), but 8K is also supported. Powers of 2 which are at most 32K may also work.</li>
<li><p class="startli">LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure which may increase performance with smaller IGZIP_HIST_SIZE values. By default this option is not defined. This define sets IGZIP_HIST_SIZE to be 8 if IGZIP_HIST_SIZE &gt; 8K.</p>
<p class="startli">As an example, to compile gzip with an 8K window size, in a terminal run </p>
<pre class="fragment">gmake D="-D IGZIP_HIST_SIZE=8*1024" </pre><p> on Linux and FreeBSD, or with</p>
<pre class="fragment">nmake -f Makefile.nmake D="-D
*   IGZIP_HIST_SIZE=8*1024" </pre><p> on Windows. </p>
</li>
</ul>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a15a192d6ccce5232a81e04a89e546025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="igzip__lib_8h.html#a15a192d6ccce5232a81e04a89e546025">isal_zstate_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compression State please note ZSTATE_TRL only applies for GZIP compression. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025ae29ac79025884cb44734bf6cc1c2dc8a"></a>ZSTATE_NEW_HDR</em>&nbsp;</td><td class="fielddoc">
<p>Header to be written. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a0732985b5f3f6326df79d3a9602a5d28"></a>ZSTATE_HDR</em>&nbsp;</td><td class="fielddoc">
<p>Header state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025aa1f5cabded72c30de4d7d259045be9d6"></a>ZSTATE_CREATE_HDR</em>&nbsp;</td><td class="fielddoc">
<p>Header to be created. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a19eb4a317476d06fe3aeb5747b4bdd94"></a>ZSTATE_BODY</em>&nbsp;</td><td class="fielddoc">
<p>Body state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a109b2268f524b66c72e518926d6a50e1"></a>ZSTATE_FLUSH_READ_BUFFER</em>&nbsp;</td><td class="fielddoc">
<p>Flush buffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a5176ea8c48e72828d68a623e1c6adf8b"></a>ZSTATE_TYPE0_BODY</em>&nbsp;</td><td class="fielddoc">
<p>Type0 block header to be written. </p>
<p>Type0 block body to be written </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025ad1bc4b252110bf3a966b60bdf1e47933"></a>ZSTATE_SYNC_FLUSH</em>&nbsp;</td><td class="fielddoc">
<p>Write sync flush block. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a06bfbb1c73e37a846f8d49444c77ef09"></a>ZSTATE_FLUSH_WRITE_BUFFER</em>&nbsp;</td><td class="fielddoc">
<p>Flush bitbuf. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a88bfe2520b8b8075ac982cf78f299629"></a>ZSTATE_TRL</em>&nbsp;</td><td class="fielddoc">
<p>Trailer state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025aed309f0832206a73cc9d3ca7ca1cefcc"></a>ZSTATE_END</em>&nbsp;</td><td class="fielddoc">
<p>End state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025ac51b1849e58365ad73de62a6dd48d8af"></a>ZSTATE_TMP_NEW_HDR</em>&nbsp;</td><td class="fielddoc">
<p>Temporary Header to be written. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a9022a6088ebb9bd63824c30fdc9bb7e6"></a>ZSTATE_TMP_HDR</em>&nbsp;</td><td class="fielddoc">
<p>Temporary Header state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a4987d9d303e6fb02ec68b7279e561a5f"></a>ZSTATE_TMP_CREATE_HDR</em>&nbsp;</td><td class="fielddoc">
<p>Temporary Header to be created state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025ad6f44c8d6ac1935f2ab547492dbfafc0"></a>ZSTATE_TMP_BODY</em>&nbsp;</td><td class="fielddoc">
<p>Temporary Body state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025aef8435f222e77fa05a876babf8096922"></a>ZSTATE_TMP_FLUSH_READ_BUFFER</em>&nbsp;</td><td class="fielddoc">
<p>Flush buffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a42d4ad449237e3adb254121514ffe552"></a>ZSTATE_TMP_TYPE0_BODY</em>&nbsp;</td><td class="fielddoc">
<p>Temporary Type0 block header to be written. </p>
<p>Temporary Type0 block body to be written </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025aeeab8dee9837e67fb0439e8c1b7bc8e2"></a>ZSTATE_TMP_SYNC_FLUSH</em>&nbsp;</td><td class="fielddoc">
<p>Write sync flush block. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025a206cc526da1927e20bbff7f1518c641c"></a>ZSTATE_TMP_FLUSH_WRITE_BUFFER</em>&nbsp;</td><td class="fielddoc">
<p>Flush bitbuf. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025aa6a864ea51b7f866425ca5e5dc155194"></a>ZSTATE_TMP_TRL</em>&nbsp;</td><td class="fielddoc">
<p>Temporary Trailer state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a15a192d6ccce5232a81e04a89e546025ad7db4e6c908ed5949574b81a19f829f9"></a>ZSTATE_TMP_END</em>&nbsp;</td><td class="fielddoc">
<p>Temporary End state. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac2adc31ec28075401ffae270df525593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t isal_adler32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate Adler-32 checksum, runs appropriate version. </p>
<p>This function determines what instruction sets are enabled and selects the appropriate version at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init,:</td><td>initial Adler-32 value </td></tr>
    <tr><td class="paramname">buf,:</td><td>buffer to calculate checksum on </td></tr>
    <tr><td class="paramname">len,:</td><td>buffer length in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit Adler-32 checksum </dd></dl>

</div>
</div>
<a class="anchor" id="a4d4699267b60c1b57c034b2adc612ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_create_hufftables </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__hufftables.html">isal_hufftables</a> *&#160;</td>
          <td class="paramname"><em>hufftables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a> *&#160;</td>
          <td class="paramname"><em>histogram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a custom huffman code for the given histograms in which every literal and repeat length is assigned a code and all possible lookback distances are assigned a code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hufftables,:</td><td>the output structure containing the huffman code </td></tr>
    <tr><td class="paramname">histogram,:</td><td>histogram containing frequency of literal symbols, repeat lengths and lookback distances </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non zero value if an invalid huffman code was created. </dd></dl>

</div>
</div>
<a class="anchor" id="aa45350d816cfdcbad55ec95284776af3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_create_hufftables_subset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__hufftables.html">isal_hufftables</a> *&#160;</td>
          <td class="paramname"><em>hufftables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a> *&#160;</td>
          <td class="paramname"><em>histogram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a custom huffman code for the given histograms like <a class="el" href="igzip__lib_8h.html#a4d4699267b60c1b57c034b2adc612ee7" title="Creates a custom huffman code for the given histograms in which every literal and repeat length is as...">isal_create_hufftables()</a> except literals with 0 frequency in the histogram are not assigned a code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hufftables,:</td><td>the output structure containing the huffman code </td></tr>
    <tr><td class="paramname">histogram,:</td><td>histogram containing frequency of literal symbols, repeat lengths and lookback distances </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a non zero value if an invalid huffman code was created. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a6d8cde91439b0aeb10b357075560e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_deflate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast data (deflate) compression for storage applications. </p>
<p>The call to <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a> will take data from the input buffer (updating next_in, avail_in and write a compressed stream to the output buffer (updating next_out and avail_out). The function returns when either the input buffer is empty or the output buffer is full.</p>
<p>On entry to <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a>, next_in points to an input buffer and avail_in indicates the length of that buffer. Similarly next_out points to an empty output buffer and avail_out indicates the size of that buffer.</p>
<p>The fields total_in and total_out start at 0 and are updated by <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a>. These reflect the total number of bytes read or written so far.</p>
<p>When the last input buffer is passed in, signaled by setting the end_of_stream, the routine will complete compression at the end of the input buffer, as long as the output buffer is big enough.</p>
<p>The compression level can be set by setting level to any value between ISAL_DEF_MIN_LEVEL and ISAL_DEF_MAX_LEVEL. When the compression level is ISAL_DEF_MIN_LEVEL, hufftables can be set to a table trained for the the specific data type being compressed to achieve better compression. When a higher compression level is desired, a larger generic memory buffer needs to be supplied by setting level_buf and level_buf_size to represent the chunk of memory. For level x, the suggest size for this buffer this buffer is ISAL_DEFL_LVLx_DEFAULT. The defines ISAL_DEFL_LVLx_MIN, ISAL_DEFL_LVLx_SMALL, ISAL_DEFL_LVLx_MEDIUM, ISAL_DEFL_LVLx_LARGE, and ISAL_DEFL_LVLx_EXTRA_LARGE are also provided as other suggested sizes.</p>
<p>The equivalent of the zlib FLUSH_SYNC operation is currently supported. Flush types can be NO_FLUSH, SYNC_FLUSH or FULL_FLUSH. Default flush type is NO_FLUSH. A SYNC_ OR FULL_ flush will byte align the deflate block by appending an empty stored block once all input has been compressed, including the buffered input. Checking that the out_buffer is not empty or that internal_state.state = ZSTATE_NEW_HDR is sufficient to guarantee all input has been flushed. Additionally FULL_FLUSH will ensure look back history does not include previous blocks so new blocks are fully independent. Switching between flush types is supported.</p>
<p>If a compression dictionary is required, the dictionary can be set calling isal_deflate_set_dictionary before calling isal_deflate.</p>
<p>If the gzip_flag is set to IGZIP_GZIP, a generic gzip header and the gzip trailer are written around the deflate compressed data. If gzip_flag is set to IGZIP_GZIP_NO_HDR, then only the gzip trailer is written. A full-featured header is supported by the isal_write_{gzip,zlib}_header() functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>COMP_OK (if everything is ok), INVALID_FLUSH (if an invalid FLUSH is selected), ISAL_INVALID_LEVEL (if an invalid compression level is selected), ISAL_INVALID_LEVEL_BUF (if the level buffer is not large enough). </dd></dl>

</div>
</div>
<a class="anchor" id="a6d311328df613652c3d1606d4a0297c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_deflate_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize compression stream data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a15edadeb459a40840e6c2f4baa59fb12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_deflate_process_dict </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__dict.html">isal_dict</a> *&#160;</td>
          <td class="paramname"><em>dict_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dict_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process dictionary to reuse later. </p>
<p>Processes a dictionary so that the generated output can be reused to reset a new deflate stream more quickly than <a class="el" href="igzip__lib_8h.html#a645ee0a2ceecb012c2f5db98541d6bd7" title="Set compression dictionary to use. ">isal_deflate_set_dict()</a> alone. This function is paired with <a class="el" href="igzip__lib_8h.html#a36116973797161ef4243c49c68b64cc2" title="Reset compression dictionary to use. ">isal_deflate_reset_dict()</a> when using the same dictionary on multiple deflate objects. The stream.level must be set prior to calling this function to process the dictionary correctly. If the dictionary is longer than IGZIP_HIST_SIZE, only the last IGZIP_HIST_SIZE bytes will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
    <tr><td class="paramname">dict_str,:</td><td>Structure to hold processed dictionary info to reuse later. </td></tr>
    <tr><td class="paramname">dict,:</td><td>Array containing dictionary to use. </td></tr>
    <tr><td class="paramname">dict_len,:</td><td>Length of dict. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>COMP_OK, ISAL_INVALID_STATE (dictionary could not be processed) </dd></dl>

</div>
</div>
<a class="anchor" id="ae582f5e4fc6a35ab8796949660259178"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_deflate_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize compression stream data structure. Performs the same action as isal_deflate_init, but does not change user supplied input such as the level, flush type, compression wrapper (like gzip), hufftables, and end_of_stream_flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a36116973797161ef4243c49c68b64cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_deflate_reset_dict </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__dict.html">isal_dict</a> *&#160;</td>
          <td class="paramname"><em>dict_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset compression dictionary to use. </p>
<p>Similar to <a class="el" href="igzip__lib_8h.html#a645ee0a2ceecb012c2f5db98541d6bd7" title="Set compression dictionary to use. ">isal_deflate_set_dict()</a> but on pre-processed dictionary data. Pairing with <a class="el" href="igzip__lib_8h.html#a15edadeb459a40840e6c2f4baa59fb12" title="Process dictionary to reuse later. ">isal_deflate_process_dict()</a> can reduce the processing time on subsequent compression with dictionary especially on small files.</p>
<p>Like <a class="el" href="igzip__lib_8h.html#a645ee0a2ceecb012c2f5db98541d6bd7" title="Set compression dictionary to use. ">isal_deflate_set_dict()</a>, this function is to be called after isal_deflate_init, or after completing a SYNC_FLUSH or FULL_FLUSH and before the next call do isal_deflate. Changing compression level between dictionary process and reset will cause return of ISAL_INVALID_STATE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
    <tr><td class="paramname">dict_str,:</td><td>Structure with pre-processed dictionary info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>COMP_OK, ISAL_INVALID_STATE or other (dictionary could not be reset) </dd></dl>

</div>
</div>
<a class="anchor" id="a645ee0a2ceecb012c2f5db98541d6bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_deflate_set_dict </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dict_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set compression dictionary to use. </p>
<p>This function is to be called after isal_deflate_init, or after completing a SYNC_FLUSH or FULL_FLUSH and before the next call do isal_deflate. If the dictionary is longer than IGZIP_HIST_SIZE, only the last IGZIP_HIST_SIZE bytes will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
    <tr><td class="paramname">dict,:</td><td>Array containing dictionary to use. </td></tr>
    <tr><td class="paramname">dict_len,:</td><td>Length of dict. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>COMP_OK, ISAL_INVALID_STATE (dictionary could not be set) </dd></dl>

</div>
</div>
<a class="anchor" id="a142e998c9897b815135742ff04102978"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_deflate_set_hufftables </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__hufftables.html">isal_hufftables</a> *&#160;</td>
          <td class="paramname"><em>hufftables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stream to use a new Huffman code. </p>
<p>Sets the Huffman code to be used in compression before compression start or after the successful completion of a SYNC_FLUSH or FULL_FLUSH. If type has value IGZIP_HUFFTABLE_DEFAULT, the stream is set to use the default Huffman code. If type has value IGZIP_HUFFTABLE_STATIC, the stream is set to use the deflate standard static Huffman code, or if type has value IGZIP_HUFFTABLE_CUSTOM, the stream is set to sue the <a class="el" href="structisal__hufftables.html" title="Holds the huffman tree used to huffman encode the input stream. ">isal_hufftables</a> structure input to isal_deflate_set_hufftables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream,:</td><td>Structure holding state information on the compression stream. </td></tr>
    <tr><td class="paramname">hufftables,:</td><td>new huffman code to use if type is set to IGZIP_HUFFTABLE_CUSTOM. </td></tr>
    <tr><td class="paramname">type,:</td><td>Flag specifying what hufftable to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns INVALID_OPERATION if the stream was unmodified. This may be due to the stream being in a state where changing the huffman code is not allowed or an invalid input is provided. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dd4d4c13d44fe96ca0d37d169fbf525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_deflate_stateless </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast data (deflate) stateless compression for storage applications. </p>
<p>Stateless (one shot) compression routine with a similar interface to <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a> but operates on entire input buffer at one time. Parameter avail_out must be large enough to fit the entire compressed output. Max expansion is limited to the input size plus the header size of a stored/raw block.</p>
<p>When the compression level is set to 1, unlike in <a class="el" href="igzip__lib_8h.html#a3a6d8cde91439b0aeb10b357075560e0" title="Fast data (deflate) compression for storage applications. ">isal_deflate()</a>, level_buf may be optionally set depending on what what performance is desired.</p>
<p>For stateless the flush types NO_FLUSH and FULL_FLUSH are supported. FULL_FLUSH will byte align the output deflate block so additional blocks can be easily appended.</p>
<p>If the gzip_flag is set to IGZIP_GZIP, a generic gzip header and the gzip trailer are written around the deflate compressed data. If gzip_flag is set to IGZIP_GZIP_NO_HDR, then only the gzip trailer is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>COMP_OK (if everything is ok), INVALID_FLUSH (if an invalid FLUSH is selected), ISAL_INVALID_LEVEL (if an invalid compression level is selected), ISAL_INVALID_LEVEL_BUF (if the level buffer is not large enough), STATELESS_OVERFLOW (if output buffer will not fit output). </dd></dl>

</div>
</div>
<a class="anchor" id="aeae02071c5f41de12b7350dc90b314fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_deflate_stateless_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize compression stream data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="aafa595cf3fdcb8f40f5ded192944c54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_gzip_header_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__gzip__header.html">isal_gzip_header</a> *&#160;</td>
          <td class="paramname"><em>gz_hdr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set gzip header default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gz_hdr,:</td><td>Gzip header to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8842e2100d3b52b94943afa5a0c5979"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_inflate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast data (deflate) decompression for storage applications. </p>
<p>On entry to <a class="el" href="igzip__lib_8h.html#ad8842e2100d3b52b94943afa5a0c5979" title="Fast data (deflate) decompression for storage applications. ">isal_inflate()</a>, next_in points to an input buffer and avail_in indicates the length of that buffer. Similarly next_out points to an empty output buffer and avail_out indicates the size of that buffer.</p>
<p>The field total_out starts at 0 and is updated by <a class="el" href="igzip__lib_8h.html#ad8842e2100d3b52b94943afa5a0c5979" title="Fast data (deflate) decompression for storage applications. ">isal_inflate()</a>. This reflects the total number of bytes written so far.</p>
<p>The call to <a class="el" href="igzip__lib_8h.html#ad8842e2100d3b52b94943afa5a0c5979" title="Fast data (deflate) decompression for storage applications. ">isal_inflate()</a> will take data from the input buffer (updating next_in, avail_in and write a decompressed stream to the output buffer (updating next_out and avail_out). The function returns when the input buffer is empty, the output buffer is full, invalid data is found, or in the case of zlib formatted data if a dictionary is specified. The current state of the decompression on exit can be read from state-&gt;block-state.</p>
<p>If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is stored in state-&gt;crc. Alternatively, if the crc_flag is set to ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state-&gt;crc (checksum may not be updated until decompression is complete). When the crc_flag is set to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same, except the checksum is verified with the checksum after immediately following the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the gzip/zlib header is parsed, state-&gt;crc is set to the appropriate checksum, and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE (default), then the data is treated as a raw deflate block.</p>
<p>The element state-&gt;hist_bits has values from 0 to 15, where values of 1 to 15 are the log base 2 size of the matching window and 0 is the default with maximum history size.</p>
<p>If a dictionary is required, a call to isal_inflate_set_dict will set the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ISAL_DECOMP_OK (if everything is ok), ISAL_INVALID_BLOCK, ISAL_NEED_DICT, ISAL_INVALID_SYMBOL, ISAL_INVALID_LOOKBACK, ISAL_INVALID_WRAPPER, ISAL_UNSUPPORTED_METHOD, ISAL_INCORRECT_CHECKSUM. </dd></dl>

</div>
</div>
<a class="anchor" id="a00513fdbbc6688c613d1a41b694ad168"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_inflate_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize decompression state data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="af6d86fe1b62a34074e908390b17e5a31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_inflate_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reinitialize decompression state data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="a5a5a24dc5d4f9a9ca3bf08b5bb0274ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_inflate_set_dict </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dict_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set decompression dictionary to use. </p>
<p>This function is to be called after isal_inflate_init. If the dictionary is longer than IGZIP_HIST_SIZE, only the last IGZIP_HIST_SIZE bytes will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state,:</td><td>Structure holding state information on the decompression stream. </td></tr>
    <tr><td class="paramname">dict,:</td><td>Array containing dictionary to use. </td></tr>
    <tr><td class="paramname">dict_len,:</td><td>Length of dict. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>COMP_OK, ISAL_INVALID_STATE (dictionary could not be set) </dd></dl>

</div>
</div>
<a class="anchor" id="adb59d093d9b8b621285fef81f82e4c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_inflate_stateless </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast data (deflate) stateless decompression for storage applications. </p>
<p>Stateless (one shot) decompression routine with a similar interface to <a class="el" href="igzip__lib_8h.html#ad8842e2100d3b52b94943afa5a0c5979" title="Fast data (deflate) decompression for storage applications. ">isal_inflate()</a> but operates on entire input buffer at one time. Parameter avail_out must be large enough to fit the entire decompressed output. Dictionaries are not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Structure holding state information on the compression streams. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ISAL_DECOMP_OK (if everything is ok), ISAL_END_INPUT (if all input was decompressed), ISAL_NEED_DICT, ISAL_OUT_OVERFLOW (if output buffer ran out of space), ISAL_INVALID_BLOCK, ISAL_INVALID_SYMBOL, ISAL_INVALID_LOOKBACK, ISAL_INVALID_WRAPPER, ISAL_UNSUPPORTED_METHOD, ISAL_INCORRECT_CHECKSUM. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fd333cf5024c376599a3fd8fb616b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_read_gzip_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__gzip__header.html">isal_gzip_header</a> *&#160;</td>
          <td class="paramname"><em>gz_hdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and return gzip header information. </p>
<p>On entry state must be initialized and next_in pointing to a gzip compressed buffer. The buffers gz_hdr-&gt;extra, gz_hdr-&gt;name, gz_hdr-&gt;comments and the buffer lengths must be set to record the corresponding field, or set to NULL to disregard that gzip header information. If one of these buffers overflows, the user can reallocate a larger buffer and call this function again to continue reading the header information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state,:</td><td>Structure holding state information on the decompression stream. </td></tr>
    <tr><td class="paramname">gz_hdr,:</td><td>Structure to return data encoded in the gzip header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ISAL_DECOMP_OK (header was successfully parsed) ISAL_END_INPUT (all input was parsed), ISAL_NAME_OVERFLOW (gz_hdr-&gt;name overflowed while parsing), ISAL_COMMENT_OVERFLOW (gz_hdr-&gt;comment overflowed while parsing), ISAL_EXTRA_OVERFLOW (gz_hdr-&gt;extra overflowed while parsing), ISAL_INVALID_WRAPPER (invalid gzip header found), ISAL_UNSUPPORTED_METHOD (deflate is not the compression method), ISAL_INCORRECT_CHECKSUM (gzip header checksum was incorrect) </dd></dl>

</div>
</div>
<a class="anchor" id="a4af9bf84dd7ca9a60eb1d07bad4a7c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isal_read_zlib_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structinflate__state.html">inflate_state</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__zlib__header.html">isal_zlib_header</a> *&#160;</td>
          <td class="paramname"><em>zlib_hdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read and return zlib header information. </p>
<p>On entry state must be initialized and next_in pointing to a zlib compressed buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state,:</td><td>Structure holding state information on the decompression stream. </td></tr>
    <tr><td class="paramname">zlib_hdr,:</td><td>Structure to return data encoded in the zlib header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ISAL_DECOMP_OK (header was successfully parsed), ISAL_END_INPUT (all input was parsed), ISAL_UNSUPPORTED_METHOD (deflate is not the compression method), ISAL_INCORRECT_CHECKSUM (zlib header checksum was incorrect) </dd></dl>

</div>
</div>
<a class="anchor" id="abcf32e76e2b6802792a5ceb4b51f1c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void isal_update_histogram </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>in_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__huff__histogram.html">isal_huff_histogram</a> *&#160;</td>
          <td class="paramname"><em>histogram</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates histograms to include the symbols found in the input stream. Since this function only updates the histograms, it can be called on multiple streams to get a histogram better representing the desired data set. When first using histogram it must be initialized by zeroing the structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_stream,:</td><td>Input stream of data. </td></tr>
    <tr><td class="paramname">length,:</td><td>The length of start_stream. </td></tr>
    <tr><td class="paramname">histogram,:</td><td>The returned histogram of lit/len/dist symbols. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e5fe18579896416b7477e6598489b28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t isal_write_gzip_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__gzip__header.html">isal_gzip_header</a> *&#160;</td>
          <td class="paramname"><em>gz_hdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write gzip header to output stream. </p>
<p>Writes the gzip header to the output stream. On entry this function assumes that the output buffer has been initialized, so stream-&gt;next_out, stream-&gt;avail_out and stream-&gt;total_out have been set. If the output buffer contains insufficient space, stream is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream,:</td><td>Structure holding state information on the compression stream. </td></tr>
    <tr><td class="paramname">gz_hdr,:</td><td>Structure holding the gzip header information to encode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the header is successfully written, otherwise returns the minimum size required to successfully write the gzip header to the output buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6409a35e068fc012e37f85fa189a999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t isal_write_zlib_header </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structisal__zstream.html">isal_zstream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structisal__zlib__header.html">isal_zlib_header</a> *&#160;</td>
          <td class="paramname"><em>z_hdr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write zlib header to output stream. </p>
<p>Writes the zlib header to the output stream. On entry this function assumes that the output buffer has been initialized, so stream-&gt;next_out, stream-&gt;avail_out and stream-&gt;total_out have been set. If the output buffer contains insufficient space, stream is not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream,:</td><td>Structure holding state information on the compression stream. </td></tr>
    <tr><td class="paramname">z_hdr,:</td><td>Structure holding the zlib header information to encode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the header is successfully written, otherwise returns the minimum size required to successfully write the zlib header to the output buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="igzip__lib_8h.html">igzip_lib.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
